
var utils = require('./');
/**
 * 
 * @param {Object} obj The object to find the function on
 * @param {Function} [caller=getKeyForCaller.caller.caller] The function to
 *      find. Defaults to the 'caller' two functions removed.
 * @returns {String}
 */
function getKeyForCaller (obj, caller) {
    var proto = Object.getPrototypeOf(obj),
        key, get, set, isGetSet;
    
    caller = caller || getKeyForCaller.caller.caller;
    
    for (key in proto) {
        get = proto.__lookupGetter__(key);
        set = proto.__lookupSetter__(key);
        isGetSet = get || set;
        
        if ((isGetSet && (get === caller || set === caller)) ||
            (!isGetSet && proto[key] === caller)
        ) {
            return key;
        }
    }
}
/**
 * Returns a list of objects from a prototype-linked chain that all contain
 * the same property key.
 * @param {Object} obj The object to traverse
 * @param {String} key The name of the property to get the chain for
 * @returns {Object[]}
 */
function getPrototypeChainForKey (obj, key) {
    var chain = [],
        hasOwn = Object.prototype.hasOwnProperty,
        getProto = Object.getPrototypeOf,
        p = obj;
    
    while (p) {
        if (hasOwn.call(p, key)) {
            chain.push(p);
        }
        p = Object.getPrototypeOf(p);
    }
    
    return chain;
}
/**
 * Link all functions on a particular prototype-chain.
 * 
 * This gives all functions in that chain a '_super' property that point to
 * its ancestor function.
 * 
 * @param {Object} obj The object to link up
 * @param {String} key The specific property name
 * @returns {undefined}
 */
function linkSuperChain (obj, key) {
    var chain = getPrototypeChainForKey(obj, key),
        prev = chain.shift(),
        prevGet = prev.__lookupGetter__(key),
        prevSet = prev.__lookupSetter__(key),
        next, nextGet, nextSet;
    
    while (prev) {
        next = chain.shift();

        if (next) {
            nextGet = next.__lookupGetter__(key);
            nextSet = next.__lookupSetter__(key);

            if (prevGet || prevSet) {
                if (prevGet && nextGet) {
                    prevGet._super = nextGet;
                }

                if (prevSet && nextSet) {
                    prevSet._super = nextSet;
                }
            }
            else {
                prev[key]._super = next[key];
            }
        }
        
        prev = next;
        prevGet = nextGet;
        prevSet = nextSet;
    }
}
/**
 * Used on the prototype of an object prototype chain.  When invoked, it
 * will place a configured function on the instance to intercept all further
 * _super calls.  This allows for recursive _super calls.  By putting it on
 * the instance, we also do not have to travel down the prototype-chain again
 * when it is invoked.
 * @returns {Function}
 */
function applySuper () {
    var firstCaller = applySuper.caller;
    
    function _super () {
        var caller = _super.caller,
            caller2, args, name, next;
        
        caller = caller === applySuper ? firstCaller : caller;
        caller2 = caller.caller;
        
        args = _super.args = arguments.length ? arguments : caller.arguments;
        
        if (caller2 === _super) {
            next = _super.next = _super.next._super;
        }
        else {
            if (!caller._super) {
                name = caller.__name__ || 
                    (caller.__name__ = getKeyForCaller(this, caller));
                linkSuperChain(this, name);
            }
            
            next = _super.next = caller._super;
        }

        return next && next.apply(this, args);
    }
    
    this._super = _super;
    return _super.apply(this, arguments.length ? arguments : firstCaller.arguments);
}
/**
 * @param {Function} superclass
 * @param {Function} [subclass=Function]
 * @param {Object} [props]
 * @param {Object} [properties={}]
 * @returns {Function}
 */
function inherit (superclass, subclass, props, properties) {
    var hasCtor, superproto, proto, key, getter, setter;
    
    if (arguments.length < 4 && typeof subclass !== 'function') {
        properties = props;
        props = subclass;
        subclass = null;
    }
    
    hasCtor = props && (props.hasOwnProperty('init') ||
        props.hasOwnProperty('constructor')) ;
    subclass = subclass || hasCtor ? (props.init || props.constructor) :
        function () { superclass.apply(this, arguments); };
    
    superproto = superclass.prototype;
    proto = Object.create(superproto);
    subclass.prototype = proto;

    properties = properties || {};
    if (props) {
        for (key in props) {
            getter = props.__lookupGetter__(key);
            setter = props.__lookupSetter__(key);
            
            if (getter || setter) {
                if (!properties.hasOwnProperty(key)) {
                    properties[key] = {
                        get: getter,
                        set: setter,
                        enumerable: true
                    };
                }
            }
            else {
                proto[key] = props[key];
            }
        }
    }
    
    properties.constructor = { value: subclass };
    if (!properties._super) {
        properties._super = { value: applySuper };
    }
    Object.defineProperties(proto, properties);
    
    subclass._super = superproto;
    subclass.extend = utils.partial(inherit, subclass);
    
    return subclass;
}
/**
 * @param {Object} props
 * @param {Object} [properties]
 * @returns {Function}
 */
function classify (props, properties) {
    return inherit(Object, null, props, properties);
}
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
utils.mixin({
    inherit:                 inherit,
    getKeyForCaller:         getKeyForCaller,
    getPrototypeChainForKey: getPrototypeChainForKey,
    linkSuperChain:          linkSuperChain,
    _super:                  applySuper
});

module.exports = classify;
