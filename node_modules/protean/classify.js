
var utils = require('./');
/**
 * 
 * @param {Object} obj The object to find the function on
 * @param {Function} [caller=getKeyForCaller.caller.caller] The function to
 *      find. Defaults to the 'caller' two functions removed.
 * @returns {String}
 */
function getKeyForCaller (obj, caller) {
    var proto = Object.getPrototypeOf(obj),
        key, get, set, isGetSet;
    
    caller = caller || getKeyForCaller.caller.caller;
    
    for (key in proto) {
        get = proto.__lookupGetter__(key);
        set = proto.__lookupSetter__(key);
        isGetSet = get || set;
        
        if ((isGetSet && (get === caller || set === caller)) ||
            (!isGetSet && proto[key] === caller)
        ) {
            return key;
        }
    }
}
/**
 * Returns a list of objects from a prototype-linked chain that all contain
 * the same property key.
 * @param {Object} obj The object to traverse
 * @param {String} key The name of the property to get the chain for
 * @returns {Object[]}
 */
function getPrototypeChainForKey (obj, key) {
    var chain = [],
        hasOwn = Object.prototype.hasOwnProperty,
        getProto = Object.getPrototypeOf,
        p = obj;
    
    while (p) {
        if (hasOwn.call(p, key)) {
            chain.push(p);
        }
        p = getProto(p);
    }
    
    return chain;
}
/**
 * Link all functions on a particular prototype-chain.
 * 
 * This gives all functions in that chain a '_super' property that point to
 * its ancestor function.
 * 
 * @param {Object} obj The object to link up
 * @param {String} key The specific property name
 * @returns {Function}
 */
function linkSuperChain (obj, key) {
    var chain = getPrototypeChainForKey(obj, key),
        root = chain.shift(),
        rootGet = root.__lookupGetter__(key),
        rootSet = root.__lookupSetter__(key),
        prev = root,
        prevGet = rootGet,
        prevSet = rootSet,
        next, nextGet, nextSet;
    
    while (prev) {
        next = chain.shift();
        
        if (next) {
            nextGet = next.__lookupGetter__(key);
            nextSet = next.__lookupSetter__(key);

            if (prevGet || prevSet) {
                if (prevGet && nextGet) {
                    prevGet._super = nextGet;
                }
                
                if (prevSet && nextSet) {
                    prevSet._super = nextSet;
                }
            }
            else {
                prev[key]._super = next[key];
            }
        }
        
        prev = next;
        prevGet = nextGet;
        prevSet = nextSet;
    }
    
    return !(rootGet || rootSet) ? root[key]._super : undefined;
}
/**
 * Link the super chains of all functions and getters/setters.
 * @param {Object} obj The object you want to link up
 */
function linkSuperChains (obj) {
    var key, get, set;
    
    for (key in obj) {
        get = obj.__lookupGetter__(key);
        set = obj.__lookupSetter__(key);
        
        if (get || set || obj[key]) {
            linkSuperChain(obj, key);
        }
    }
}
/**
 * Used on the prototype of an object prototype chain.  When invoked, it
 * will place a configured function on the instance to intercept all further
 * _super calls.  This allows for recursive _super calls.  By putting it on
 * the instance, we also do not have to travel down the prototype-chain again
 * when it is invoked.
 * @returns {Function}
 */
function _super () {
    var caller = _super.caller,
        fn = caller._super || linkSuperChain(this, getKeyForCaller(this, caller));
    return fn && fn.apply(this, arguments.length ? arguments : caller.arguments);
}
/**
 * @param {Function} superclass
 * @param {Function} [subclass=Function]
 * @param {Object} [props]
 * @param {Object} [properties={}]
 * @returns {Function}
 */
function inherit (superclass, subclass, props, properties) {
    var hasCtor, superproto, proto, key, getter, setter;
    
    if (arguments.length < 4 && typeof subclass !== 'function') {
        properties = props;
        props = subclass;
        subclass = null;
    }
    
    hasCtor = props && props.hasOwnProperty('constructor') ;
    subclass = subclass || hasCtor && props.constructor ||
        function () { superproto.constructor.apply(this, arguments); };
    
    superproto = superclass.prototype;
    proto = Object.create(superproto);
    subclass.prototype = proto;

    properties = properties || {};
    if (props) {
        for (key in props) {
            getter = props.__lookupGetter__(key);
            setter = props.__lookupSetter__(key);
            
            if (getter || setter) {
                if (!properties.hasOwnProperty(key)) {
                    properties[key] = {
                        get: getter,
                        set: setter,
                        enumerable: true
                    };
                }
            }
            else {
                proto[key] = props[key];
            }
        }
    }
    
    properties.constructor = { value: subclass };
    if (!properties._super) {
        properties._super = { value: _super };
    }
    Object.defineProperties(proto, properties);
    
    subclass._super = superclass;
    subclass._proto = superproto;
    subclass.extend = utils.partial(inherit, subclass);
    
    return subclass;
}
/**
 * @param {Object} props
 * @param {Object} [properties]
 * @returns {Function}
 */
function classify (props, properties) {
    return inherit(Object, null, props, properties);
}
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
utils.mixin({
    inherit:                 inherit,
    getKeyForCaller:         getKeyForCaller,
    getPrototypeChainForKey: getPrototypeChainForKey,
    linkSuperChain:          linkSuperChain,
    _super:                  _super
});

module.exports = classify;
