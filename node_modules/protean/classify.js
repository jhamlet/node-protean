
var utils = require('./'),
    nutil = require('util');

function getKeyOfCaller (obj, caller) {
    var name, key, isGet, isSet;
    
    caller = caller || getKeyOfCaller.caller.caller;
    name = caller && caller.__name__;
    
    if (!name) {
        for (key in obj) {
            isGet = obj.__lookupGetter__(key);
            isSet = obj.__lookupSetter__(key);
            
            if (isGet === caller || isSet === caller || obj[key] === caller) {
                name = key;
                break;
            }
        }
    }
    
    return name;
}

function getPrototypeChainFor (obj, name) {
    var chain = [],
        p = obj;
    
    while (p) {
        if (p.hasOwnProperty(name)) {
            chain.push(p);
        }
        p = Object.getPrototypeOf(p);
    }
    
    return chain;
}

function linkSupers (obj, name) {
    var chain = getPrototypeChainFor(obj, name);
    // TODO: if methods in the chain are already linked, don't re-link them?
    chain.reduce(function (prev, next) {
        var get = next.__lookupGetter__(name),
            set = next.__lookupSetter__(name),
            prevGet = prev.__lookupGetter__(name),
            prevSet = prev.__lookupSetter__(name);

        if (set || get) {
            if (get && prevGet) {
                prevGet._super = get;
            }

            if (set && prevSet) {
                prevSet._super = set;
            }
        }
        else {
            prev[name]._super = next[name];
        }
        
        return next;
    });
}

function applySuper (instance, caller, args) {
    var ret;
    
    function _super () {
        var args = arguments.length ? (_super.args = arguments) : _super.args;
        
        if (_super.caller.caller === _super) {
            // Recursive _super call: use next
            _super.next = _super.next._super;
        }
        return _super.next && _super.next.apply(_super.instance, args);
    }
    
    if (!caller._super) {
        linkSupers(instance, getKeyOfCaller(instance, caller));
    }
    
    _super.instance = instance;
    _super.next = caller._super;
    _super.args = args.length ? args : caller.arguments;
    
    instance._super = _super;
    ret = _super.apply(instance, _super.args);
    delete instance._super;
    
    return ret;
}

function _super () {
    return applySuper(this, _super.caller, arguments);
}

function classify (subclass, superclass, props, properties) {
    var methodKeys = [],
        hasCtor, proto, key, isGet, isSet;
    
    if (!utils.isFunction(superclass)) {
        properties = props;
        props = superclass;
        superclass = subclass;
        subclass = null;
    }
    
    hasCtor = props && props.hasOwnProperty('constructor');
    subclass = subclass ||
        (hasCtor && props.constructor) ||
        function () { superclass.apply(this, arguments); };

    superclass = superclass || Object;
    proto = Object.create(superclass.prototype);
    
    properties = properties || {};
    if (props) {
        for (key in props) {
            isGet = props.__lookupGetter__(key);
            isSet = props.__lookupGetter__(key);
            
            if (isGet || isSet) {
                if (!properties.hasOwnProperty(key)) {
                    properties[key] = {
                        get: isGet,
                        set: isSet,
                        enumerable: true
                    };
                }
                methodKeys.push(key);
            }
            else {
                proto[key] = props[key];
                if (typeof proto[key] === 'function') {
                    methodKeys.push(key);
                }
            }
        }
    }
    
    properties.constructor = { value: subclass };
    if (!proto._super) {
        properties._super = { value: _super };
    }
    Object.defineProperties(proto, properties);
    
    subclass._super = superclass;
    subclass.extend = utils.partial(classify, subclass);
    
    methodKeys.
        forEach(function (key) {
            linkSupers(proto, key);
        });
        
    return subclass;
}
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
utils.mixin({
    getKeyOfCaller:       getKeyOfCaller,
    getPrototypeChainFor: getPrototypeChainFor
});

module.exports = utils.extend(classify, {
    _super: _super,
    linkSupers: linkSupers,
    applySuper: applySuper
});
