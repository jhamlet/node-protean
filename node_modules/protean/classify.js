
var utils = require('./');

function getKeyForCaller (obj, caller) {
    var key, get, set;
    
    caller = caller || getKeyForCaller.caller.caller;
    
    for (key in obj) {
        get = obj.__lookupGetter__(key);
        set = obj.__lookupSetter__(key);

        if (get === caller || set === caller || obj[key] === caller) {
            return key;
        }
    }
}

function getPrototypeChainForKey (obj, key) {
    var chain = [],
        hasOwn = Object.prototype.hasOwnProperty,
        getProto = Object.getPrototypeOf,
        p = obj;
    
    while (p) {
        if (hasOwn.call(p, key)) {
            chain.push(p);
        }
        p = Object.getPrototypeOf(p);
    }
    
    return chain;
}

function linkSupers (obj, key) {
    var chain = getPrototypeChainForKey(obj, key),
        prev = chain.shift(),
        prevGet = prev.__lookupGetter__(key),
        prevSet = prev.__lookupSetter__(key),
        next, nextGet, nextSet;
    
    while (prev) {
        next = chain.shift();

        if (next) {
            nextGet = next.__lookupGetter__(key);
            nextSet = next.__lookupSetter__(key);

            if (prevGet || prevSet) {
                if (prevGet && nextGet) {
                    prevGet._super = nextGet;
                }

                if (prevSet && nextSet) {
                    prevSet._super = nextSet;
                }
            }
            else {
                prev[key]._super = next[key];
            }
        }
        
        prev = next;
        prevGet = nextGet;
        prevSet = nextSet;
    }
}

function applySuper () {
    var caller = applySuper.caller,
        args = arguments.length ? arguments : caller.arguments,
        _super = this._superProxy,
        name,
        ret;
    
    if (!_super) {
        _super = this._superProxy = function superProxy () {
            var caller = _super.caller,
                args = arguments.length ? (_super.args = arguments) : _super.args;

            if (caller.caller === _super) {
                _super.next = _super.next._super;
            }

            return _super.next && _super.next.apply(this, args);
        };
    }
    
    if (!caller._super) {
        name = caller.__name__ || 
            (caller.__name__ = getKeyForCaller(this, caller));
        linkSupers(this, name);
    }
    
    _super.next = caller._super;
    _super.args = args;
    
    this._super = _super;
    ret = _super.apply(this, args);
    this._superProxy = this._super;
    this._super = applySuper;
    
    return ret;
}
/**
 * @param {Function} superclass
 * @param {Function} [subclass=Function]
 * @param {Object} props
 * @param {Object} [properties]
 * @returns {Function}
 */
function inherits (superclass, subclass, props, properties) {
    var hasCtor, superproto, proto, key, getter, setter;
    
    if (arguments.length < 4 && !utils.isFunction(subclass)) {
        properties = props;
        props = subclass;
        subclass = null;
    }
    
    hasCtor = props && (props.hasOwnProperty('init') ||
        props.hasOwnProperty('constructor')) ;
    subclass = subclass || hasCtor ? (props.init || props.constructor) :
        function () { superclass.apply(this, arguments); };
    
    superproto = superclass.prototype;
    proto = Object.create(superproto);
    subclass.prototype = proto;

    properties = properties || {};
    if (props) {
        for (key in props) {
            getter = props.__lookupGetter__(key);
            setter = props.__lookupSetter__(key);
            
            if (getter || setter) {
                if (!properties.hasOwnProperty(key)) {
                    properties[key] = {
                        get: getter,
                        set: setter,
                        enumerable: true
                    };
                }
            }
            else {
                proto[key] = props[key];
            }
        }
    }
    
    properties.constructor = { value: subclass };
    if (!properties._super) {
        properties._super = { value: applySuper };
    }
    Object.defineProperties(proto, properties);
    
    subclass._super = superproto;
    subclass.extend = utils.partial(inherits, subclass);
    
    return subclass;
}
/**
 * @param {Object} props
 * @param {Object} [properties]
 * @returns {Function}
 */
function classify (props, properties) {
    return inherits(Object, null, props, properties);
}
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
utils.mixin({
    inherits:                inherits,
    getKeyForCaller:         getKeyForCaller,
    getPrototypeChainForKey: getPrototypeChainForKey,
    linkSupers:              linkSupers,
    _super:                  applySuper
});

module.exports = classify;
