/**
 * @author jerry hamlet <jerry@hamletink.com>
 */
var _ = require('underscore'),
    _mixin = _.mixin;

_.mixin = function () {
    _mixin.apply(_, arguments);
    return _;
};
//---------------------------------------------------------------------------
// Exports First
//---------------------------------------------------------------------------
module.exports = exports = _;
//---------------------------------------------------------------------------
// Local
//---------------------------------------------------------------------------
/**
 * @param {...Mixed}
 * @returns {Object}
 */
function hashify () {
    var args = _.rest(arguments, 0);
    return _.object(args, args);
}

function enumerate () {
    return _.reduce(arguments, function (acc, cur, idx) {
        acc[cur] = idx + 1;
        return acc;
    }, {});
}
/**
 * @param {String} name Name of the function to alias.
 * @param {Object} [scope] Optional scope to use. If not given, uses the current 'this'.
 * @param {Mixed[]} [args] Optional list of arguments to prepend when calling
 *      the aliased function.
 * @returns {Function}
 */
function alias (name, scope, args) {
    if (arguments.length < 3 && _.isArray(scope)) {
        args = scope;
        scope = null;
    }
    
    args = args || [];
    
    return function () {
        var obj = scope || this,
            fn = obj[name];
        
        return fn.apply(obj, args.concat(_.rest(arguments, 0)));
    };
}
/**
 * Create a getter on the object that when first accessed executes the given
 * function and replaces the named getter with the value returned from the
 * function.
 * @param {Object} obj The object
 * @param {String} name The property name
 * @param {Function} fn The function to execute
 * @param {Boolean} [hidden=false] Should the propery be enumerable
 * @returns {Object} The object passed in
 */
function lazily (obj, name, fn, hidden) {
    hidden = !!hidden;
    return Object.defineProperty(obj, name, {
        get: function () {
            var val = fn();
            Object.defineProperty(obj, name, {
                value: val,
                enumerable: !hidden,
                writable: !hidden,
                configurable: !hidden
            });
            return val;
        },
        enumerable: !hidden,
        configurable: true
    });
}

function lazilyRequire (obj, name, module) {
    return lazily(obj, name, require.bind(null, module));
}
/**
 * @param {Function} [subclass]
 * @param {Function} superclass
 * @param {Object} [props]
 * @param {Object} [properties]
 */
function inherits (subclass, superclass, props, properties) {
    var ctor, proto, superproto, parent;
    
    if (!_.isFunction(superclass)) {
        properties = props;
        props = superclass;
        superclass = subclass;
        ctor = props && props.hasOwnProperty('constructor') && props.constructor;
        subclass = ctor || function () {
            superclass.apply(this, arguments);
        };
    }
    
    superproto = superclass.prototype;
    proto = Object.create(superproto);
    subclass.prototype = proto;
    
    if (props) {
        _.extend(proto, props);
    }
    
    if (properties) {
        Object.defineProperties(proto, properties);
    }
    
    Object.defineProperty(proto, 'constructor', {
        value: subclass,
        enumerable: false
    });
    
    subclass._super = superclass;
    subclass.extend = function (props, properties) {
        return inherits(subclass, props, properties);
    };
    
    function _super () {
        var self = this,
            caller = _super.caller,
            caller2 = caller.caller,
            name = caller.name || caller.__label__,
            args = arguments.length ? arguments : caller.arguments,
            key,
            fn,
            ret;

        parent = parent || proto;
        
        if (!name) {
            // no name for function, lets find it and label it
            for (key in parent) {
                if (parent[key] === caller) {
                    name = key;
                    break;
                }
            }
            caller.__label__ = name;
        }
        
        if (caller2 === _super) {
            // recursive protean call -- lets up our parent reference
            parent = Object.getPrototypeOf(parent);
        }
        
        fn = parent[name];
        ret = fn && fn.apply(this, args);
        // reset our parent reference
        parent = null;
        return ret;
    }
    proto._super = _super;
    
    return subclass;
}

function classify (props, properties) {
    var ctor = props && props.hasOwnProperty('constructor') && props.constructor;
    return inherits(ctor, Object, props, properties);
}
/**
 * Create a new object and then apply the constructor function with the arguments.
 * @param {Function} fn
 * @param {Mixed[]} [args]
 * @returns {Object} The new instance
 */
function instantiate (fn, args) {
    var obj = Object.create(fn.prototype);
    fn.apply(obj, args || []);
    return obj;
}
//---------------------------------------------------------------------------
// Update Exports
//---------------------------------------------------------------------------
exports.extend(exports, {
    hashify:        hashify,
    enumerate:      enumerate,
    alias:          alias,
    inherits:       inherits,
    classify:       classify,
    instantiate:    instantiate,
    make:           instantiate,
    lazily:         lazily
});

lazilyRequire(exports, 'rx', 'rx');
lazilyRequire(exports, 'LinkedList', './linked-list');
