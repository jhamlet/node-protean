
var utils = require('protean');
//---------------------------------------------------------------------------
// List Item
//---------------------------------------------------------------------------
function Item (data, prev, next) {
    var item = this;
    
    if (data instanceof Item) {
        item = data;
        data = item.data;
        prev = item.prev;
        next = item.next;
    }
    
    item.data = data;
    if (next) {
        next.prev = item;
    }
    item.next = next;
    if (prev) {
        prev.next = item;
    }
    item.prev = prev;
    
    return item;
}

Item.prototype = {
    insert: function (item) {
        var n = this.next;
            
        this.next = item;
        item.next = n;
        item.prev = this;
        
        return this;
    },
    
    insertBefore: function (item) {
        var p = this.prev;
        
        this.prev = item;
        item.next = this;
        item.prev = p;
        
        return this;
    },
    
    remove: function () {
        var p = this.prev,
            n = this.next;
        
        p.next = n;
        n.prev = p;
        
        this.data = this.prev = this.next = null;
        
        return this;
    },
    
    swap: function () {
        var n = this.next,
            p = this.prev;
        
        this.prev = n;
        if (n) {
            n.next = p;
        }
        
        this.next = p;
        if (p) {
            p.prev = n;
        }
        
        return this;
    }
};
//---------------------------------------------------------------------------
// List
//---------------------------------------------------------------------------
function LinkedList () {
    if (!(this instanceof LinkedList)) {
        return utils.instantiate(LinkedList, arguments);
    }
    this.head = null;
    this.tail = null;
    this.length = 0;
    this.push.apply(this, arguments);
}

LinkedList.fromArray = function (list) {
    return utils.instantiate(LinkedList, list);
};

LinkedList.prototype = {
    
    reset: function () {
        LinkedList.call(this);
    },
    /**
     * Return the item at index 'idx'.  Index=0 returns the 'head' item, and
     * index=-1 returns the 'tail' item.  Otherwise we have to traverse the
     * list.
     * @param {Integer} idx
     * @returns {Mixed}
     */
    get: function (idx) {
        var h = this.head;
        // TODO: This could probably be optimized to traverse from either
        // direction (head or tail) depending on how close idx is to either
        // 0 or length.
        if (idx < 0) {
            idx = this.length + idx;
        }
        
        if (idx === this.length - 1) {
            h = this.tail;
        }
        else if (idx > 0 && h) {
            while (idx-- > 0 && h) {
                h = h.next;
            }
        }
        
        return h && h.data;
    },
    
    set: function (idx, data) {
        var c = this.get(idx),
            val;
            
        if (c) {
            val = c.data;
            c.data = data;
        }
        
        return val;
    },
    
    insert: function (idx, data) {
        var p = this.get(idx);
        if (p) {
            p.insert(new Item(data));
        }
        return this;
    },
    
    insertBefore: function (idx, data) {
        var n = this.get(idx);
        if (n) {
            n.insertBefore(new Item(data));
        }
        return this;
    },
    
    remove: function (idx) {
        var c = this.get(idx);
        if (c) {
            c.remove();
            this.length--;
        }
        return this;
    },
    
    push: function () {
        var arglen = arguments.length;
        
        if (arglen > 1) {
            utils.each(arguments, function (arg) {
                this.push(arg);
            }, this);
        }
        else if (arglen) {
            this.tail = new Item(arguments[0], this.tail, null);
            if (!this.head) {
                this.head = this.tail;
            }
            this.length++;
        }
        
        return this.length;
    },
    
    pop: function () {
        var t = this.tail,
            len;
        
        if (this.length === 0) {
            return;
        }
        
        this.tail = t.prev;
        
        if (t.prev) {
            t.prev = this.tail.next = null;
        }
        
        len = --this.length;
        
        if (len === 1) {
            this.head = this.tail;
        }
        else if (len === 0) {
            this.head = this.tail = null;
        }
        
        return t.data;
    },
    
    unshift: function () {
        var arglen = arguments.length;
        
        if (arglen > 1) {
            utils.each(arguments, function (arg) {
                this.unshift(arg);
            }, this);
        }
        else if (arglen) {
            this.head = new Item(arguments[0], null, this.head);
            if (!this.tail) {
                this.tail = this.head;
            }
            this.length++;
        }
        
        return this.length;
    },
    
    shift: function () {
        var h = this.head,
            len;
        
        if (this.length === 0) {
            return;
        }
        
        this.head = h.next;
        if (h.next) {
            h.next = this.prev = null;
        }
        
        len = --this.length;
        
        if (len === 1) {
            this.head = this.tail;
        }
        else if (len === 0) {
            this.head = this.tail = null;
        }
        
        return h.data;
    },

    reverse: function () {
        var c = this.head,
            p = null,
            n;
        
        if (this.length > 1) {
            this.tail = c;

            while (c) {
                n = c.next;
                c.next = p;
                p = c;
                c = n;
            }

            this.head = p;
        }
        
        return this;
    },
    
    slice: function (start, stop) {
        var list = new LinkedList(),
            h,
            i,
            len;
        
        if (!start) {
            start = 0;
        }
        if (!stop) {
            stop = this.length;
        }
        if (stop < 0) {
            stop = this.length + stop;
        }
        if (start < 0) {
            start = this.length + start;
        }
        
        if (start !== stop || stop > start) {
            h = this.head;
            i = 0;
            len = stop - start;

            while (start-- > 0 && h) {
                h = h.next;
            }

            while (i < len && h) {
                list.push(h.data);
                h = h.next;
                i++;
            }
        }
        
        return list;
    },
    //-----------------------------------------------------------------------
    // Enumeration
    //-----------------------------------------------------------------------
    forEach: function (fn, scope) {
        var i = 0,
            item = this.head,
            len = this.length;
        
        while (i < len && item) {
            fn.call(scope, item.data, i, this);
            item = item.next;
            i++;
        }
    },
    
    each: utils.alias('forEach'),
    
    map: function (fn, scope) {
        var list = new LinkedList();
        
        this.forEach(function (data, idx, self) {
            list.push(fn.call(scope, data, idx, self));
        });
        
        return list;
    },
    
    filter: function (fn, scope) {
        var list = new LinkedList();
        
        this.forEach(function (data, idx, self) {
            if (fn.call(scope, data, idx, self)) {
                list.push(data);
            }
        });
        
        return list;
    },
    
    reduce: function (fn, init, scope) {
        var val = init,
            i = 0,
            len = this.length,
            h = this.head;
        
        if (!val) {
            val = h && h.data;
            i = 1;
            h = h && h.next;
        }
        
        while (i++ < len && h) {
            val = fn.call(scope, val, h.data, this);
            i++;
            h = h.next;
        }
        
        return val;
    },
    
    some: function (fn, scope) {
        var i = 0,
            item = this.head,
            len = this.length,
            result = true;
        
        while (i < len && item && result) {
            result = fn.call(scope, item.data, i, this);
            item = item.next;
            i++;
        }
        
        return result;
    },
    
    every: function (fn, scope) {
        var i = 0,
            item = this.head,
            len = this.length,
            result = false;
        
        do {
            result = fn.call(scope, item.data, i, this);
            item = item.next;
            i++;
        }
        while (i < len && item && result);
        
        return result;
    },
    //-----------------------------------------------------------------------
    // Utility
    //-----------------------------------------------------------------------
    join: function () {
        var list = this.toArray();
        return list.join.apply(list, arguments);
    },
    
    toArray: function () {
        var list = [];
        
        this.forEach(function (item) {
            list.push(item);
        });
        
        return list;
    },
    
    toString: utils.alias('join')    
};
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
LinkedList.Item = Item;
module.exports = LinkedList;
