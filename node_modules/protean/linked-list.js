
var utils = require('protean');
//---------------------------------------------------------------------------
// List Item
//---------------------------------------------------------------------------
function Item (data, prev, next) {
    this.data = data;
    if (next) {
        next.prev = this;
    }
    this.next = next;
    if (prev) {
        prev.next = this;
    }
    this.prev = prev;
}

Item.prototype = {
    insert: function (item) {
        var n = this.next;
            
        this.next = item;
        item.next = n;
        item.prev = this;
        
        return this;
    },
    
    insertBefore: function (item) {
        var p = this.prev;
        
        this.prev = item;
        item.next = this;
        item.prev = p;
        
        return this;
    },
    
    destroy: function () {
        var p = this.prev,
            n = this.next;
        
        p.next = n;
        n.prev = p;
        
        this.data = this.prev = this.next = null;
        
        return this;
    },
    
    swap: function () {
        var n = this.next,
            p = this.prev;
        
        this.prev = n;
        if (n) {
            n.next = p;
        }
        
        this.next = p;
        if (p) {
            p.prev = n;
        }
        
        return this;
    }
};
//---------------------------------------------------------------------------
// Cursor
//---------------------------------------------------------------------------
function Cursor (list) {
    this.list = list;
    this.rewind();
}

Cursor.prototype = {
    destroy: function () {
        this.list = null;
        this.item = null;
    },
    
    rewind: function () {
        this.item = this.list.head;
        this.index = 0;
        return this;
    },
    
    ffwd: function () {
        var list = this.list;
        this.item = list.tail;
        this.index = list.length - 1;
        return this;
    },
    
    moveTo: function (idx) {
        var delta = idx - this.index;
        // TODO: Optimize to move from head or tail depending on how far idx is
        // from either of those.
        if (idx === 0) {
            this.rewind();
        }
        else if (idx === -1) {
            this.ffwd();
        }
        else {
            this.moveBy(delta);
        }
        
        return this;
    },
    
    moveBy: function (amt) {
        var method = amt > 0 ? 'next' : 'prev',
            delta = this.index + amt,
            i = Math.abs(amt);
        
        if (amt !== 0) {
            while (i-- && this.item) {
                this[method]();
            }
        }
        
        return this;
    },
    
    next: function () {
        var c = this.item || this.list.head;

        if (c) {
            this.item = c.next;
            this.index++;
        }
        
        return this;
    },
    
    prev: function () {
        var p = this.item || this.list.head;
        
        if (p) {
            this.item = p.prev;
            this.index--;
        }
        
        return this;
    },
    
    insert: function (data) {
        var item;
        if (item) {
            item.insert(new Item(data));
        }
        return this;
    },
    
    insertBefore: function (data) {
        var item;
        if (item) {
            item.insertBefore(new Item(data));
        }
        return this;
    },
    
    remove: function () {
        var item = this.item;
        if (item) {
            item.destroy();
        }
        return this;
    },
    
    get value () {
        var item = this.item;
        return item && item.data;
    },
    
    set value (v) {
        this.item.data = v;
    }
};
//---------------------------------------------------------------------------
// List
//---------------------------------------------------------------------------
function LinkedList () {
    if (!(this instanceof LinkedList)) {
        return utils.instantiate(LinkedList, arguments);
    }
    this.head = null;
    this.tail = null;
    this.length = 0;
    this.push.apply(this, arguments);
}

LinkedList.fromArray = function (list) {
    return utils.instantiate(LinkedList, list);
};

LinkedList.prototype = {
    
    reset: function () {
        LinkedList.call(this);
    },
    
    destroy: utils.alias('reset'),
    /**
     * Return the item at index 'idx'.  Index=0 returns the 'head' item, and
     * index=-1 returns the 'tail' item.  Otherwise we have to traverse the
     * list.
     * @param {Integer} idx
     * @returns {Mixed}
     */
    get: function (idx) {
        var cursor = this.getCursor();
        
        if (idx === 0) {
            cursor.rewind();
        }
        else if (idx < 0) {
            cursor.ffwd();
            cursor.moveBy(idx + 1);
        }
        else {
            cursor.moveTo(idx);
        }
        
        return cursor.value;
    },
    
    set: function (idx, data) {
        var cursor = this.getCursor();
        
        if (idx === 0) {
            cursor.rewind();
        }
        else if (idx < 0) {
            cursor.ffwd();
            cursor.moveBy(idx + 1);
        }
        else {
            cursor.moveTo(idx);
        }
        
        cursor.value = data;
        return this;
    },
    
    insert: function (idx, data) {
        this.getCursor().moveTo(idx).insert(new Item(data));
        this.length++;
        return this;
    },
    
    insertBefore: function (idx, data) {
        this.getCursor().moveTo(idx).insertBefore(new Item(data));
        this.length++;
        return this;
    },
    
    remove: function (idx) {
        this.getCursor().moveTo(idx).item.destroy();
        this.length--;
        return this;
    },
    
    push: function () {
        var arglen = arguments.length;
        
        if (arglen > 1) {
            utils.each(arguments, function (arg) {
                this.push(arg);
            }, this);
        }
        else if (arglen) {
            this.tail = new Item(arguments[0], this.tail, null);
            if (!this.head) {
                this.head = this.tail;
            }
            this.length++;
        }
        
        return this.length;
    },
    
    pop: function () {
        var t = this.tail,
            len;
        
        if (this.length === 0) {
            return;
        }
        
        this.tail = t.prev;
        
        if (t.prev) {
            t.prev = this.tail.next = null;
        }
        
        len = --this.length;
        
        if (len === 1) {
            this.head = this.tail;
        }
        else if (len === 0) {
            this.head = this.tail = null;
        }
        
        return t.data;
    },
    
    unshift: function () {
        var arglen = arguments.length;
        
        if (arglen > 1) {
            utils.each(arguments, function (arg) {
                this.unshift(arg);
            }, this);
        }
        else if (arglen) {
            this.head = new Item(arguments[0], null, this.head);
            if (!this.tail) {
                this.tail = this.head;
            }
            this.length++;
        }
        
        return this.length;
    },
    
    shift: function () {
        var h = this.head,
            len;
        
        if (this.length === 0) {
            return;
        }
        
        this.head = h.next;
        if (h.next) {
            h.next = this.prev = null;
        }
        
        len = --this.length;
        
        if (len === 1) {
            this.head = this.tail;
        }
        else if (len === 0) {
            this.head = this.tail = null;
        }
        
        return h.data;
    },

    reverse: function () {
        var c = this.head,
            p = null,
            n;
        
        if (this.length > 1) {
            this.tail = c;

            while (c) {
                n = c.next;
                c.next = p;
                p = c;
                c = n;
            }

            this.head = p;
        }
        
        return this;
    },
    
    slice: function (start, stop) {
        var list = new LinkedList(),
            cursor = this.getCursor();
        
        if (!start) {
            start = 0;
        }
        if (!stop) {
            stop = this.length;
        }
        if (stop < 0) {
            stop = this.length + stop;
        }
        if (start < 0) {
            start = this.length + start;
        }
        
        if (start !== stop || stop > start) {
            cursor.moveTo(start);
            do {
                list.push(cursor.value);
                cursor.next();
                start++;
            }
            while (start < stop);
        }
        
        return list;
    },
    //-----------------------------------------------------------------------
    // Enumeration
    //-----------------------------------------------------------------------
    iterate: function (dir, fn, scope) {
        var cursor = this.getCursor(),
            isFwd = dir !== 'rev',
            method = isFwd ? 'next' : 'prev';
        
        cursor[isFwd ? 'rewind' : 'ffwd']();
        
        while (cursor.item) {
            fn.call(scope, cursor.value, cursor.index, this);
            cursor[method]();
        }
        
        return this;
    },
    
    forEach: utils.alias('iterate', ['fwd']),
    each:    utils.alias('forEach'),
    
    map: function (fn, scope) {
        var list = new LinkedList();
        
        this.iterate('fwd', function (data, idx, self) {
            list.push(fn.call(scope, data, idx, self));
        });
        
        return list;
    },
    
    filter: function (fn, scope) {
        var list = new LinkedList();
        
        this.iterate('fwd', function (data, idx, self) {
            if (fn.call(scope, data, idx, self)) {
                list.push(data);
            }
        });
        
        return list;
    },
    
    reduce: function (fn, init, scope) {
        var val = init,
            i = 0,
            len = this.length,
            h = this.head;
        
        if (!val) {
            val = h && h.data;
            i = 1;
            h = h && h.next;
        }
        
        while (i++ < len && h) {
            val = fn.call(scope, val, h.data, this);
            i++;
            h = h.next;
        }
        
        return val;
    },
    
    some: function (fn, scope) {
        var i = 0,
            item = this.head,
            len = this.length,
            result = true;
        
        while (i < len && item && result) {
            result = fn.call(scope, item.data, i, this);
            item = item.next;
            i++;
        }
        
        return result;
    },
    
    every: function (fn, scope) {
        var i = 0,
            item = this.head,
            len = this.length,
            result = false;
        
        do {
            result = fn.call(scope, item.data, i, this);
            item = item.next;
            i++;
        }
        while (i < len && item && result);
        
        return result;
    },
    //-----------------------------------------------------------------------
    // Utility
    //-----------------------------------------------------------------------
    join: function () {
        var list = this.toArray();
        return list.join.apply(list, arguments);
    },
    
    toArray: function () {
        var list = [];
        
        this.iterate('fwd', function (item) {
            list.push(item);
        });
        
        return list;
    },
    
    toString: utils.alias('join'),
    
    getCursor: function () {
        return new Cursor(this);
    }
};
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
LinkedList.Item = Item;
LinkedList.Cursor = Cursor;
module.exports = LinkedList;
