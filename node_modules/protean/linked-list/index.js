
var utils = require('protean'),
    Item = require('./item'),
    Cursor = require('./cursor');

const FORWARD    = 'fwd';
const REVERSE    = 'rev';
const ITERATE    = 'iterate';
const ACCUMULATE = 'accumulate';
const TRANSLATE  = 'translate';
const SIFT       = 'sift';
const TEST       = 'test';
//---------------------------------------------------------------------------
// List
//---------------------------------------------------------------------------
function LinkedList () {
    if (!(this instanceof LinkedList)) {
        return utils.instantiate(LinkedList, arguments);
    }
    this.head = null;
    this.tail = null;
    this.length = 0;
    this.push.apply(this, arguments);
}

LinkedList.fromArray = function (list) {
    return utils.instantiate(LinkedList, list);
};

LinkedList.prototype = {
    
    reset: function () {
        LinkedList.call(this);
    },
    
    destroy: utils.alias('reset'),
    /**
     * Return the item at index 'idx'.  Index=0 returns the 'head' item, and
     * index=-1 returns the 'tail' item.  Otherwise we have to traverse the
     * list.
     * @param {Integer} idx
     * @returns {Mixed}
     */
    get: function (idx) {
        var cursor = this.getCursor();
        
        if (idx === 0) {
            cursor.rewind();
        }
        else if (idx < 0) {
            cursor.ffwd();
            cursor.moveBy(idx + 1);
        }
        else {
            cursor.moveTo(idx);
        }
        
        return cursor.value;
    },
    
    set: function (idx, data) {
        var cursor = this.getCursor();
        
        if (idx === 0) {
            cursor.rewind();
        }
        else if (idx < 0) {
            cursor.ffwd();
            cursor.moveBy(idx + 1);
        }
        else {
            cursor.moveTo(idx);
        }
        
        cursor.value = data;
        return this;
    },
    
    insert: function (idx, data) {
        this.getCursor().moveTo(idx).insert(new Item(data));
        return this;
    },
    
    insertBefore: function (idx, data) {
        this.getCursor().moveTo(idx).insertBefore(new Item(data));
        return this;
    },
    
    remove: function (idx) {
        this.getCursor().moveTo(idx).item.destroy();
        return this;
    },
    
    push: function () {
        var arglen = arguments.length;
        
        if (arglen > 1) {
            utils.each(arguments, function (arg) {
                this.push(arg);
            }, this);
        }
        else if (arglen) {
            this.tail = new Item(arguments[0], this.tail, null);
            if (!this.head) {
                this.head = this.tail;
            }
            this.length++;
        }
        
        return this.length;
    },
    
    pop: function () {
        var t = this.tail,
            len;
        
        if (this.length === 0) {
            return;
        }
        
        this.tail = t.prev;
        
        if (t.prev) {
            t.prev = this.tail.next = null;
        }
        
        len = --this.length;
        
        if (len === 1) {
            this.head = this.tail;
        }
        else if (len === 0) {
            this.head = this.tail = null;
        }
        
        return t.data;
    },
    
    unshift: function () {
        var arglen = arguments.length;
        
        if (arglen > 1) {
            utils.each(arguments, function (arg) {
                this.unshift(arg);
            }, this);
        }
        else if (arglen) {
            this.head = new Item(arguments[0], null, this.head);
            if (!this.tail) {
                this.tail = this.head;
            }
            this.length++;
        }
        
        return this.length;
    },
    
    shift: function () {
        var h = this.head,
            len;
        
        if (this.length === 0) {
            return;
        }
        
        this.head = h.next;
        if (h.next) {
            h.next = this.prev = null;
        }
        
        len = --this.length;
        
        if (len === 1) {
            this.head = this.tail;
        }
        else if (len === 0) {
            this.head = this.tail = null;
        }
        
        return h.data;
    },

    reverse: function () {
        var c = this.head,
            p = null,
            n;
        
        if (this.length > 1) {
            this.tail = c;

            while (c) {
                n = c.next;
                c.next = p;
                p = c;
                c = n;
            }

            this.head = p;
        }
        
        return this;
    },
    
    slice: function (start, stop) {
        var list = new LinkedList(),
            cursor = this.getCursor();
        
        if (!start) {
            start = 0;
        }
        if (!stop) {
            stop = this.length;
        }
        if (stop < 0) {
            stop = this.length + stop;
        }
        if (start < 0) {
            start = this.length + start;
        }
        
        if (start !== stop || stop > start) {
            cursor.moveTo(start);
            do {
                list.push(cursor.value);
                cursor.next();
                start++;
            }
            while (start < stop);
        }
        
        return list;
    },
    //-----------------------------------------------------------------------
    // Enumeration
    //-----------------------------------------------------------------------
    iterate: function (dir, fn, scope) {
        var cursor = this.getDirectedCursor(dir);
        
        while (cursor.item) {
            fn.call(scope, cursor.value, cursor.index, this);
            cursor.advance();
        }
        
        cursor.destroy();
        
        return this;
    },
    
    forEach:        utils.alias(ITERATE, [FORWARD]),
    forEachRight:   utils.alias(ITERATE, [REVERSE]),
    forEachReverse: utils.alias(ITERATE, [REVERSE]),

    each:           utils.alias(ITERATE, [FORWARD]),
    eachRight:      utils.alias(ITERATE, [REVERSE]),
    eachReverse:    utils.alias(ITERATE, [REVERSE]),
    
    accumulate: function (dir, fn, init, scope) {
        var cursor = this.getDirectedCursor(dir),
            data = init;
        
        if (!data) {
            data = cursor.value;
            cursor.advance();
        }
        
        while (cursor.item) {
            data = fn.call(scope, data, cursor.value, cursor.index, this);
            cursor.advance();
        }
        
        cursor.destroy();
        
        return data;
    },
    
    reduce:        utils.alias(ACCUMULATE, [FORWARD]),
    reduceRight:   utils.alias(ACCUMULATE, [REVERSE]),
    reduceReverse: utils.alias(ACCUMULATE, [REVERSE]),
    
    translate: function (dir, fn, scope) {
        return this.accumulate(dir, function (acc, data, idx, self) {
            acc.push(fn.call(scope, data, idx, acc));
            return acc;
        }, new LinkedList());
    },
    
    map:        utils.alias(TRANSLATE, [FORWARD]),
    mapRight:   utils.alias(TRANSLATE, [REVERSE]),
    mapReverse: utils.alias(TRANSLATE, [REVERSE]),

    sift: function (dir, fn, scope) {
        return this.accumulate(dir, function (acc, data, idx, self) {
            if (fn.call(scope, data, idx, acc)) {
                acc.push(data);
            }
            return acc;
        }, new LinkedList());
    },
    
    filter:        utils.alias(SIFT, [FORWARD]),
    filterRight:   utils.alias(SIFT, [REVERSE]),
    filterReverse: utils.alias(SIFT, [REVERSE]),

    test: function (dir, fn, scope) {
        var cursor = this.getDirectedCursor(dir),
            list = new LinkedList(),
            result = true;
        
        while (cursor.item && result) {
            result = fn.call(scope, cursor.value, cursor.index, this);
            cursor.advance();
        }
        
        cursor.destroy();
        
        return (result && true) || false;
    },
    
    some:         utils.alias(TEST, [FORWARD]),
    someRight:    utils.alias(TEST, [REVERSE]),
    someReverse:  utils.alias(TEST, [REVERSE]),
    
    every:        utils.alias(TEST, [FORWARD]),
    everyRight:   utils.alias(TEST, [REVERSE]),
    everyReverse: utils.alias(TEST, [REVERSE]),
    //-----------------------------------------------------------------------
    // Utility
    //-----------------------------------------------------------------------
    join: function () {
        var list = this.toArray();
        return list.join.apply(list, arguments);
    },
    
    toArray: function () {
        var list = [];
        
        this.iterate(FORWARD, function (item) {
            list.push(item);
        });
        
        return list;
    },
    
    toString: utils.alias('join'),
    
    getCursor: function () {
        return new Cursor(this);
    },
    
    getDirectedCursor: function (dir) {
        var cursor = this.getCursor(),
            isFwd = dir !== REVERSE,
            alias = isFwd ? 'next' : 'prev';
        
        cursor[isFwd ? 'rewind' : 'ffwd']();
        cursor.advance = utils.alias(alias);
        
        return cursor;
    }
};
//---------------------------------------------------------------------------
// Exports
//---------------------------------------------------------------------------
LinkedList.Item = Item;
LinkedList.Cursor = Cursor;
module.exports = LinkedList;
